<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <title>FPV Sampa GSS</title>
    <meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no, viewport-fit=cover" />
	<meta name="HandheldFriendly" content="true" />
	<link rel="icon" type="image/png" href="favicon.png" />
	
	<!-- Apple Stuff-->
	<meta name="apple-mobile-web-app-capable" content="yes" />
	<meta name="apple-mobile-web-app-title" content="Bullet GCSS" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black" />
	<link rel="apple-touch-icon" href="apple-touch-icon.png">
	<link rel="apple-touch-icon" sizes="120x120" href="apple-touch-icon-120.png">
	<link rel="apple-touch-icon" sizes="152x152" href="apple-touch-icon-152.png">
	<link rel="apple-touch-icon" sizes="167x167" href="apple-touch-icon-167.png">
	<link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon-180.png">
	<link rel="apple-touch-icon" sizes="512x512" href="apple-touch-icon-512.png">
	<link rel="apple-touch-icon" sizes="1024x1024" href="apple-touch-icon-1024.png">

    <script src="mqttws31.js" type="text/javascript"></script>
	<link href="https://fonts.googleapis.com/css?family=Ubuntu&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/ol.css" type="text/css">
	<style>
		html,
		body {
			margin:0;
			padding:0;
			height:100%;
			overflow: hidden;
			font-family: Ubuntu;
			font-size: 3.5vmin;
			background-color: black;
			color: white;

			-webkit-touch-callout: none;
			-webkit-user-select: none;
			-khtml-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
			touch-action: none;
		}

		.color-danger {
			color: red;
		}

		.color-ok {
			color: green;
		}
		
		.map {
			height: 100%;
			width: 100%;
		}

		#dataview {
			display: flex;
			overflow: auto;
		}

		.tblDataView {
			width: 100%;
			align-self: center;
			margin: 1em;
		}

		.titleBox {
			align-self: center;
		}
		
		.statusIcon {
			height: 2em;
			width: 2em;
		}

		.rightIcon {
			right: 1em;
			position: absolute;
		}

		.textIcon {
			height: 1em;
			width: 1em;
		}

		/* Portrait */
		@media only screen and (orientation : portrait)
		{
			#container {
				min-height:100%;
				position:relative;
				overflow: hidden;
			}
			#dataview {
				height:30%;
				width:100%;
				position:absolute;
				bottom:70%;
			}
			#mapview {
				height:40%;
				width:100%;
				bottom:30%;
				position:absolute;
			}
			#hudview {
				height:30%;
				width:100%;
				bottom:0;
				position:absolute;
			}
			@supports(bottom: max(0px)) {
				#headerview {
					bottom: calc(90% + max(0px, env(safe-area-inset-bottom)));
				}
				#dataview {
					bottom: calc(70% + max(0px, env(safe-area-inset-bottom)));
				}
				#mapview {
					bottom: calc(30% + max(0px, env(safe-area-inset-bottom)));
				}
				#hudview {
					bottom: max(0px, env(safe-area-inset-bottom));
				}
			}
		}

		/* Landscape */
		@media only screen and (orientation : landscape)
		{
			#container {
				min-height:100%;
				position:relative;
				overflow: hidden;
			}
			#dataview {
				position:absolute;
				width:50%;
				right:50%;
				top: 0;
				height: 50%;
			}
			#mapview {
			   position:absolute;
			   top: 0;
			   width:50%;
			   right:0;
			   height:100%;
			}
			#hudview {
			   position:absolute;
			   top:50%;
			   right:50%;
			   width:50%;
			   height:50%;
			}
			@supports(bottom: max(0px)) {
				#dataview {
					width: calc(50% - env(safe-area-inset-left) - 1em);
				}
				#mapview {
					height: calc(100% - max(0px, env(safe-area-inset-bottom)));
				}
			}
		}

	</style>
	<script src="ol/ol.js"></script>
	<script src="js/olc.min.js"></script>
	<script src="js/NoSleep.min.js"></script>
  </head>
  <body>
    <div id="container">
		<div id="dataview">
			<table class="tblDataView">
				<tr>
					<td colspan="2" class="statusIconBar">
						<img class="statusIcon" id="connectionIcon" src="img/connection_broken.png" />
						<img class="statusIcon" id="cellIcon" src="img/cell_broken.png" />
						<img class="statusIcon" id="radioIcon" src="img/rx_bad.png" />
						<img class="statusIcon" id="batteryIcon" src="img/battery_0.png" />
						<img class="statusIcon" id="gpsIcon" src="img/gps_bad.png" />
						<img class="statusIcon" id="hardwareHealthIcon" src="img/health_error.png" />
						<img class="statusIcon rightIcon" id="gearIcon" src="img/whitegear.png" onclick="enableWakeLock();" />
					</td>
				</tr>
				<tr>
					<td width="50%">Callsign</td>
					<td width="50%" id="callsignPlaceHolder"></td>
				</tr>
				<tr>
					<td width="50%">Active mode</td>
					<td width="50%" id="activeModePlaceHolder"></td>
				</tr>
				<tr>
					<td>Coordinates</td>
					<td id="coordinatesPlaceHolder"></td>
				</tr>
				<tr>
					<td>Home Distance</td>
					<td id="homeDistancePlaceHolder"></td>
				</tr>
				<tr>
					<td>Waypoint mission</td>
					<td id="waipointPlaceHolder"></td>
					<td id="waipointPlaceHolder"></td>
				</tr>
				<tr>
					<td>GPS Info</td>
					<td id="gpsInfoPlaceHolder"></td>
				</tr>
				<tr>
					<td>Azimuth / Elevation</td>
					<td id="aziElevPlaceHolder"></td>
				</tr>
			</table>
		</div>
		<div id="mapview">
			<div id="map" class="map"></div>
		</div>
		<div id="hudview">
			<canvas id="cvsEFIS"></canvas>
		</div>
	</div>

	<script>
		// Setup viewport
		var windowOuterWidth = 0;

		var noSleep = new NoSleep();
		function enableWakeLock() {
			noSleep.enable();
		}

		function UpdateViewPortSize(resize=true) {
			if(windowOuterWidth != window.outerWidth) {
				windowOuterWidth = window.outerWidth;
				var width = windowOuterWidth * window.devicePixelRatio;
				viewport = document.querySelector("meta[name=viewport]");
				viewport.setAttribute('content', 'width=' + width + ', viewport-fit=cover');

				if(resize)
					window.dispatchEvent(new Event('resize'));
			}
		}
		
		UpdateViewPortSize();

		window.addEventListener("orientationchange", function() {
			UpdateViewPortSize();
		}, false);


		// Setup Map
		var Map = ol.Map;
		var Overlay = ol.Overlay;
		var View = ol.View;
		var Feature = ol.Feature;
		var Point = ol.geom.Point;
		var TileJSON = ol.source.TileJSON;
		var VectorSource = ol.source.Vector;
		var TileLayer = ol.layer.Tile;
		var VectorLayer = ol.layer.Vector;
		var toStringHDMS = ol.coordinate.toStringHDMS;
		var toLonLat = ol.proj.toLonLat;
		var Icon = ol.style.Icon;
		var Style = ol.style.Style;

		var map = new ol.Map({
		target: 'map',
		layers: [
			new ol.layer.Tile({
			source: new ol.source.OSM()
			})
		],
		view: new ol.View({
			center: ol.proj.fromLonLat([-46.6652, -23.5467]),
			zoom: 16
		})
		});

		var user_moved_map = false;
		map.on('pointerdrag', function (event) {
			if(user_moved_map == false) {
				user_moved_map = true;
				console.log("User moved the map");
			}
		});

		// Setup MQTT
		/*
		host = 'test.mosquitto.org';	// hostname or IP address
		port = 8080;
		*/
		host = 'broker.emqx.io';	// hostname or IP address
		port = 8083;
		topic = 'revspace/sensors/dnrbtelem';		// topic to subscribe to
		useTLS = false;
		username = null;
		password = null;
		cleansession = true;

		var mqtt;
		var reconnectTimeout = 2000;

		var mqttConnected = false;
		var lastMessageDate = new Date(2000, 1, 1);

		function MQTTconnect() {
		if (typeof path == "undefined") {
			path = '/mqtt';
		}
		mqtt = new Paho.MQTT.Client(
				host,
				port,
				path,
				"web_" + parseInt(Math.random() * 100, 10)
		);
			var options = {
				timeout: 3,
				useSSL: useTLS,
				cleanSession: cleansession,
				onSuccess: onConnect,
				onFailure: function (message) {
					console.log("Connection failed: " + message.errorMessage + ". Retrying...");
					setTimeout(MQTTconnect, reconnectTimeout);
				}
			};

			mqtt.onConnectionLost = onConnectionLost;
			mqtt.onMessageArrived = onMessageArrived;

			if (username != null) {
				options.userName = username;
				options.password = password;
			}
			console.log("Host="+ host + ", port=" + port + ", path=" + path + " TLS = " + useTLS + " username=" + username + " password=" + password);
			mqtt.connect(options);
		}

		function onConnect() {
			console.log('Connected to ' + host + ':' + port + path);
			// Connection succeeded; subscribe to our topic
			mqtt.subscribe(topic, {qos: 0});
			console.log(topic);
			mqttConnected = true;
		}

		function onConnectionLost(response) {
			setTimeout(MQTTconnect, reconnectTimeout);
			console.log("connection lost: " + responseObject.errorMessage + ". Reconnecting...");
			mqttConnected = false;
		};

		function onMessageArrived(message) {

			var topic = message.destinationName;
			var payload = message.payloadString;

			console.log(payload);
			lastMessageDate = new Date();
			parseTelemetryData(payload);
		};

		// MQTTconnect();

		// Setup
		var data = {
			rollAngle: 0, // decimal deg from -180.0 to 180.0
			pitchAngle: 0, // decimal deg from -90.0 to 90.0
			heading: 35, // decimal deg from -180.0 to 180.0
			altitude: 4000, // int centimeters
			altitudeSeaLevel: 400, // int meters
			groundSpeed: 1450, // int centimeters per second
			airSpeed: 1350, // int centimeters per second
			verticalSpeed: 125, // int centimeters per second
			homeDirection: 35, // decimal deg from -180.0 to 180.0
			homeDistance: 60000, // centimeters
			fuelPercent: 50,
			battCellVoltage: 3.67,
			batteryVoltage: 14.0,
			batteryCellCount: 4,
			currentDraw: 5.6, // Amps
			capacityDraw: 2345, // mAh
			rssiPercent: 95,
			gpsSatCount: 12,
			gpsHDOP: 1.2,
			gpsLatitude: -23.5467,
			gpsLongitude: -46.6652,
			currentWaypointNumber: 0,
			waypointCount: 0,
			azimuth: 100,
			elevation: 6,
			dataTimestamp: new Date(2000, 1, 1),
			flightMode: "N/A",
			cellSignalStrength: 3,
			gps3DFix: 0,
			isHardwareHealthy: 0,
			uavIsArmed: 0,
			isWaypointMissionValid: 0,
			callsign: "UNKNOWN",
			powerTime: 0,
			flightTime: 0,
		};

		function parseTelemetryData(payload) {
			var arrPayload = payload.split(",");

			for(var i=0; i < arrPayload.length; i++) {
				if(arrPayload[i] == "")
					continue;

				var arrData = arrPayload[i].split(":");
				switch(arrData[0]) {
					case "ran":
						data.rollAngle = parseFloat(arrData[1] / 10.0);
						break;
					case "pan":
						data.pitchAngle = parseFloat(arrData[1] / 10.0);
						break;
					case "hea":
						data.heading = parseFloat(arrData[1] / 10.0);
						break;
					case "alt":
						data.altitude = parseInt(arrData[1]);
						break;
					case "asl":
						data.altitudeSeaLevel = parseInt(arrData[1]);
						break;
					case "gsp":
						data.groundSpeed = parseInt(arrData[1]);
						break;
					case "vsp":
						data.verticalSpeed = parseInt(arrData[1]);
						break;
					case "hdr":
						data.homeDirection = parseFloat(arrData[1]) / 10.0;
						break;
					case "hds":
						data.homeDistance = parseInt(arrData[1]);
						break;
					case "cud":
						data.currentDraw = parseFloat(arrData[1]);
						break;
					case "cad":
						data.capacityDraw = parseInt(arrData[1]);
						break;
					case "rsi":
						data.rssiPercent = parseInt(arrData[1]);
						break;
					case "gsc":
						data.gpsSatCount = parseInt(arrData[1]);
						break;
					case "gla":
						data.gpsLatitude = parseFloat(arrData[1]);
						break;
					case "glo":
						data.gpsLongitude = parseFloat(arrData[1]);
						break;
					case "ghp":
						data.gpsHDOP = parseFloat(arrData[1]);
						break;
					case "acv":
						data.battCellVoltage = parseFloat(arrData[1]);
						break;
					case "bpv":
						data.batteryVoltage = parseFloat(arrData[1]);
						break;
					case "bcc":
						data.batteryCellCount = parseInt(arrData[1]);
						break;
					case "bfp":
						data.fuelPercent = parseInt(arrData[1]);
						break;
					case "css":
						data.cellSignalStrength = parseInt(arrData[1]);
						break;
					case "ftm":
						data.flightMode = arrData[1];
						break;
					case "cwn":
						data.currentWaypointNumber = parseInt(arrData[1]);
						break;
					case "wpc":
						data.waypointCount = parseInt(arrData[1]);
						break;
					case "3df":
						data.gps3DFix = parseInt(arrData[1]);
						break;
					case "hwh":
						data.isHardwareHealthy = parseInt(arrData[1]);
						break;
					case "arm":
						data.uavIsArmed = parseInt(arrData[1]);
						break;
					case "wpv":
						data.isWaypointMissionValid = parseInt(arrData[1]);
						break;
					case "cs":
						data.callsign = arrData[1];
						break;
					case "ont":
						data.powerTime = parseInt(arrData[1]);
						break;
					case "flt":
						data.flightTime = parseInt(arrData[1]);
						break;
					default:
						break;

				}
			}
			data.dataTimestamp = new Date();
		}

		var efis = {
			verticalFOV: 60, // Degrees
			horizontalFOV: 50, // Degrees
			AHIStepsDeg: 10, // Degrees
			SpeedUnitLabel: 'km/h',
			SpeedUnitFactor: 0.036, // value that * m/s result in speed on Unit desired (0.036 = m/s to km/h)
			SpeedFOV: 50, // value is on Speed unit (ex: 50 km/h)
			SpeedSteps: 10, // Each line on the Speed scrolling bar
			AltitudeFOV: 50, // value is on Altitude Unit (ex: 50 m)
			AltitudeSteps: 10, // Each line on the Altitude Scrolling bar
			AltitudeUnitLabel: 'mts',
			AltitudeUnitFactor: 100, // value that * cm result in altitude on Unit desired (100 = cm to m)
			AltitudeSmallTextNumber: 2, // Last X numbers of altitude will be smaller than the remaining first ones
			VerticalSpeedUnitFactor: 100, // value that * cm/s result in the vertical speed unit desired (100 = cm/s to m/s)
			VerticalSpeedUnitLabel: 'm/s', 
			VerticalSpeedSteps: 2, // Each line on the Vertical Speed bar
			VerticalSpeedFOV: 8, // from 0 to this number (and negative too)
			qtyBlocks: 18, // How many horizontal and vertical chuncks the hud will be divided
			fontSizeFactor: 3, // (HUD Height / qtyBlocks) * fontSizeFactor
			horizonSizeFactor: 8, // Greater number, shorter AHI lines
			hudView: document.getElementById("hudview"),
			efisCanvas: document.getElementById("cvsEFIS"),
			DefaultFont: 'Ubuntu',
		};

		function P(x, y) { return {x: x, y: y}; }		

		function getParallelSegment(A, B, d, side) {
			// --- Return a line segment parallel to AB, d pixels away
			var dx = A.x - B.x,
				dy = A.y - B.y,
				dist = Math.sqrt(dx*dx + dy*dy) / 2;
			side = side || 1;
			dx *= side * d / dist;
			dy *= side * d / dist;
			return [P(A.x + dy, A.y - dx), P(B.x + dy, B.y - dx)];
		}

		function sq(x) { return x*x ;}

		function buildUnitVector(p1, p2, uVect) {
			uVect.x = (p2.x - p1.x);
			uVect.y = (p2.y - p1.y );
			var vectorNorm = Math.sqrt( sq(uVect.x)+sq(uVect.y) );
			uVect.x/=vectorNorm;
			uVect.y/=vectorNorm;
		}

		function drawProgressBar(ctx, text, x, y, w, h, fillPercent, color, font, borderSize) {
			ctx.beginPath();
			ctx.strokeStyle = color;
			ctx.fillStyle = color;
			ctx.lineWidth = borderSize;
			ctx.rect(x, y, w, h);
			ctx.fillRect(x, y, ((w / 100) * fillPercent), h);

			drawTextWithShadow(ctx, text, x + (w / 2), y + (h / 1.5) + borderSize, font, 'center', 'white', 'black', borderSize);

			ctx.stroke();
			ctx.closePath();

		}

		function drawTextWithShadow(ctx, text, x, y, font, textAlign, textColor, shadowColor, shadowDistance) {
			ctx.font = font;
			ctx.textAlign = textAlign;
			ctx.fillStyle = shadowColor;
			efis.efisContext.fillText(text, x + shadowDistance, y + shadowDistance);
			ctx.fillStyle = textColor;
			ctx.fillText(text, x, y);
		}

		function drawShorterLine(ctx, p1, p2, a, b) {
			buildUnitVector(p1, p2, unitVector);
			sp1.x = p1.x + unitVector.x * a;
			sp1.y = p1.y + unitVector.y * a;
			sp2.x = p2.x - unitVector.x * b;
			sp2.y = p2.y - unitVector.y * b;
			ctx.beginPath();
			ctx.moveTo(sp1.x, sp1.y);
			ctx.lineTo(sp2.x, sp2.y);
			ctx.stroke();
		}
		var unitVector = { x:0, y:0 }, sp1 = {x:0,y:0},	sp2 = {x:0, y:0 } ; 		

		function lineDistance( point1, point2 ){
			var xs = 0;
			var ys = 0;

			xs = point2.x - point1.x;
			xs = xs * xs;

			ys = point2.y - point1.y;
			ys = ys * ys;

			return Math.sqrt( xs + ys );
		}

		function correctPitchAngle(data, line, pitchDegPixels) {
			var correctedPitchAngle = data.pitchAngle;
			if(correctedPitchAngle > 90) {
				// Aircraft is upside down. Start decreasing pitch angle and flip horizon
				correctedPitchAngle = 180 - correctedPitchAngle;
			} else if(correctedPitchAngle < -90) {
				// Aircraft is upside down. Start decreasing pitch angle and flip horizon
				correctedPitchAngle = 180 + correctedPitchAngle;
			}
			
			// On INAV, nose down means positive number and nose up negative. Fix it now.
			correctedPitchAngle = correctedPitchAngle * -1;
			
			var rollAngleRad = data.rollAngle * (Math.PI / 180);
			var pitchAngleRad = correctedPitchAngle * (Math.PI / 180);
			var cosRoll = Math.cos(rollAngleRad);
			var sinRoll = Math.sin(rollAngleRad);
			var cosPitch = Math.cos(pitchAngleRad);
			var sinPitch = Math.sin(pitchAngleRad);
			
			line[0].y += pitchDegPixels * cosRoll * correctedPitchAngle;
			line[1].y += pitchDegPixels * cosRoll * correctedPitchAngle;

			line[0].x += pitchDegPixels * -sinRoll * correctedPitchAngle;
			line[1].x += pitchDegPixels * -sinRoll * correctedPitchAngle;
		
		}
		
		function drawBox(ctx, coordinates, size, borderSize, borderColor, boxColor) {
			ctx.fillStyle = borderColor;
			ctx.fillRect(coordinates.x, coordinates.y, size.x, size.y);
			ctx.fillStyle = boxColor;
			ctx.fillRect(coordinates.x + borderSize, coordinates.y + borderSize, size.x - (borderSize * 2), size.y - (borderSize * 2));
		}

		function pad(num, size) {
			var s = num+"";
			while (s.length < size) s = "0" + s;
			return s;
		}

		function drawBoxWithTextAbsPosition(ctx, text, textColor, textSize, textAlign, position, size, placeholder, smallNumbers = 0) {
			var bigText = text;
			var smallText = bigText.toString().slice(-smallNumbers);
			var smallTextWidth = 0;
			if(smallNumbers>0) {
				ctx.font = (textSize/2) + 'px ' + efis.DefaultFont;
				smallTextWidth = ctx.measureText(smallText).width;
				bigText = text.toString().substring(0, text.toString().length - smallNumbers);
				/*
				console.log("Small: " + smallText + " - " + smallTextWidth);
				console.log("Big: " + bigText);
				*/
			}

			ctx.font = textSize + 'px ' + efis.DefaultFont;
			drawBox(ctx, position, size, 2, textColor, 'black');
			ctx.fillStyle = textColor;
			ctx.textAlign = textAlign;
			var textStartPosition = 0;

			if(textAlign=='right')
				textStartPosition = size.x / 1.1;
			else if(textAlign=='center')
				textStartPosition = size.x / 2;

			if(smallNumbers>0) {
				ctx.font = (textSize/2) + 'px ' + efis.DefaultFont;
				ctx.fillText(smallText, position.x + textStartPosition, position.y + (textSize / 1.5));
			}
			ctx.font = textSize + 'px ' + efis.DefaultFont;
			ctx.fillText(bigText, position.x + textStartPosition - smallTextWidth, position.y + (textSize / 1.2));
		}

		function drawBoxWithText(ctx, text, textColor, textSize, textAlign, position, placeholder) {
			ctx.font = textSize + 'px ' + efis.DefaultFont;
			var boxWidth = ctx.measureText(placeholder).width * 1.1;

			if(textAlign=='right')
				position.x -= boxWidth;
			else if(textAlign=='center')
				position.x -= boxWidth / 2;

			drawBoxWithTextAbsPosition(ctx, text, textColor, textSize, textAlign, position, P(boxWidth, textSize), placeholder)
		}

		function drawEfisHeadingIndicator() {
			var numberY = efis.efisHeight - (efis.fontSize);
			var lineY1 = numberY + (efis.fontSize);
			var lineY2 = numberY + (efis.fontSize * 0.1);

			for(i=0; i<=359; i+=efis.AHIStepsDeg) {
				var startingPosX = (efis.efisWidth / 2) - (data.heading * (efis.efisWidth / efis.horizontalFOV));
				var numberX = startingPosX + (i * (efis.efisWidth / efis.horizontalFOV) );
				var numberXNeg = startingPosX + (-i * (efis.efisWidth / efis.horizontalFOV) );
				var txtAngle = pad(i, 3);
				var txtAngleNeg = pad(360 - i, 3);

				if(i==0) {
					txtAngle = "N";
					txtAngleNeg = "N";
				}

				if(i==90) {
					txtAngle = "E";
					txtAngleNeg = "W";
				}

				if(i==180) {
					txtAngle = "S";
					txtAngleNeg = "S";
				}

				if(i==270) {
					txtAngle = "W";
					txtAngleNeg = "E";
				}

				efis.efisContext.beginPath();
				efis.efisContext.lineWidth = 1;
				efis.efisContext.fillStyle = 'white';
				efis.efisContext.font = efis.fontSize + 'px ' + efis.DefaultFont;
				efis.efisContext.textAlign = "center";
				efis.efisContext.fillText(txtAngle, numberX, numberY);
				efis.efisContext.moveTo(numberX, lineY1);
				efis.efisContext.lineTo(numberX, lineY2);
				efis.efisContext.moveTo(numberX + ((efis.efisWidth / efis.horizontalFOV) * (efis.AHIStepsDeg /2)), lineY1);
				efis.efisContext.lineTo(numberX + ((efis.efisWidth / efis.horizontalFOV) * (efis.AHIStepsDeg /2)), lineY2);
				if(i>0) {
					efis.efisContext.fillText(txtAngleNeg, numberXNeg, numberY);
					efis.efisContext.moveTo(numberXNeg, lineY1);
					efis.efisContext.lineTo(numberXNeg, lineY2);
					efis.efisContext.moveTo(numberXNeg + ((efis.efisWidth / efis.horizontalFOV) * (efis.AHIStepsDeg /2)), lineY1);
					efis.efisContext.lineTo(numberXNeg + ((efis.efisWidth / efis.horizontalFOV) * (efis.AHIStepsDeg /2)), lineY2);
				}
				efis.efisContext.strokeStyle = 'white';
				efis.efisContext.stroke();
				efis.efisContext.closePath();
			}

			efis.efisContext.beginPath();
			var headingDisplay = data.heading;
			if(headingDisplay < 0)
				headingDisplay = 360 + headingDisplay;
			headingDisplay = pad(parseInt(headingDisplay), 3);

			drawBoxWithText(efis.efisContext, headingDisplay + 'ยบ', 'white', efis.fontSize * 2, 'center', P((efis.efisWidth / 2), efis.efisHeight - (efis.fontSize * 2)), '000ยบ');
			efis.efisContext.closePath();
		}

		function drawEfisHorizonGroundSky() {
			// Render Sky and Ground
			// Make the horizon line angle
			efis.horizonX1 = (efis.efisWidth / 2);
			efis.horizonY1 = (efis.efisHeight / 2);
			efis.rollAngleRad = data.rollAngle * (Math.PI / 180);
			efis.horizonX2 = parseInt(efis.horizonX1 + (efis.lineLength * Math.cos(efis.rollAngleRad)));
			efis.horizonY2 = parseInt(efis.horizonY1 + (efis.lineLength * Math.sin(efis.rollAngleRad)));
			efis.horizonX1 = efis.efisWidth - efis.horizonX2;
			efis.horizonY1 = efis.efisHeight - efis.horizonY2;
			var HorizonLine = [P(efis.horizonX1, efis.horizonY1), P(efis.horizonX2, efis.horizonY2)];
			
			// Apply pitch to the Horizon line
			correctPitchAngle(data, HorizonLine, efis.pitchDegPixels);
			
			// Draw Sky
			var SkyLine = getParallelSegment(P(HorizonLine[0].x, HorizonLine[0].y), P(HorizonLine[1].x, HorizonLine[1].y), efis.lineLength, -1);
			efis.efisContext.beginPath();
			efis.efisContext.moveTo(SkyLine[0].x, SkyLine[0].y);
			efis.efisContext.lineTo(HorizonLine[0].x, HorizonLine[0].y);
			efis.efisContext.lineTo(HorizonLine[1].x, HorizonLine[1].y);
			efis.efisContext.lineTo(SkyLine[1].x, SkyLine[1].y);
			efis.efisContext.closePath();
			efis.efisContext.fillStyle = '#0086ad';
			efis.efisContext.fill();
			
			// Draw Ground
			var GroundLine = getParallelSegment(P(HorizonLine[0].x, HorizonLine[0].y), P(HorizonLine[1].x, HorizonLine[1].y), efis.lineLength, 1);
			efis.efisContext.beginPath();
			efis.efisContext.moveTo(HorizonLine[0].x, HorizonLine[0].y);
			efis.efisContext.lineTo(GroundLine[0].x, GroundLine[0].y);
			efis.efisContext.lineTo(GroundLine[1].x, GroundLine[1].y);
			efis.efisContext.lineTo(HorizonLine[1].x, HorizonLine[1].y);
			efis.efisContext.closePath();
			efis.efisContext.fillStyle = '#744044';
			efis.efisContext.fill();
			
			// Draw horizon line
			efis.efisContext.beginPath();
			efis.efisContext.moveTo(HorizonLine[0].x, HorizonLine[0].y);
			efis.efisContext.lineTo(HorizonLine[1].x, HorizonLine[1].y);
			efis.efisContext.strokeStyle = 'white';
			efis.efisContext.stroke();
			efis.efisContext.closePath();
		}

		function drawEfisArtifitialHorizonStepLines() {
			efis.horizonX1 = (efis.efisWidth / 2);
			efis.horizonY1 = (efis.efisHeight / 2);
			efis.horizonX2 = (efis.horizonX1 + ((efis.efisWidth / efis.horizonSizeFactor) * Math.cos(efis.rollAngleRad)));
			efis.horizonY2 = (efis.horizonY1 + ((efis.efisWidth / efis.horizonSizeFactor) * Math.sin(efis.rollAngleRad)));
			efis.horizonX1 = efis.efisWidth - efis.horizonX2;
			efis.horizonY1 = efis.efisHeight - efis.horizonY2;
			var AHILine = [P(efis.horizonX1, efis.horizonY1), P(efis.horizonX2, efis.horizonY2)];
			var halfLineLength = lineDistance(AHILine[0], AHILine[1]) / 4;

			correctPitchAngle(data, AHILine, efis.pitchDegPixels);
			
			for(i=0; i<=180; i+=efis.AHIStepsDeg / 2) {
				
				var StepsRadius = efis.verticalFOV / 3;
				var dataPitchAngle = data.pitchAngle * -1; // Fix INAV inverted pitch angle
				var StepsStart = dataPitchAngle - StepsRadius;
				var StepsFinish = dataPitchAngle + StepsRadius;

				var renderPos = true;
				var renderNeg = true;

				if(StepsStart >= 0 && i < StepsStart)
					renderPos = false;

				if(StepsFinish >= 0 && i > StepsFinish)
					renderPos = false;

				if(StepsStart <= 0 && -i < StepsStart)
					renderNeg = false;

				if(StepsFinish <= 0 && -i > StepsFinish)
					renderNeg = false;

				if(StepsStart >= 0 && StepsFinish > 0)
					renderNeg = false;

				if(StepsStart < 0 && StepsFinish < 0)
					renderPos = false;

				var distanceFromHorizon = (i * efis.pitchDegPixels) / 2;
				var fullLine = (i % efis.AHIStepsDeg == 0);
				
				var AHIStepLine = AHILine;
				var AHIStepLineNeg = AHILine;

				if(i>0) {
					AHIStepLine = getParallelSegment(P(AHILine[0].x, AHILine[0].y), P(AHILine[1].x, AHILine[1].y), distanceFromHorizon, -1);
					AHIStepLineNeg = getParallelSegment(P(AHILine[0].x, AHILine[0].y), P(AHILine[1].x, AHILine[1].y), distanceFromHorizon, 1);
				}

				efis.efisContext.beginPath();
				if(fullLine) {
					if(renderPos) {
						efis.efisContext.moveTo(AHIStepLine[0].x, AHIStepLine[0].y);
						efis.efisContext.lineTo(AHIStepLine[1].x, AHIStepLine[1].y);
					}
					if(i>0) {
						if(renderNeg) {
							efis.efisContext.moveTo(AHIStepLineNeg[0].x, AHIStepLineNeg[0].y);
							efis.efisContext.lineTo(AHIStepLineNeg[1].x, AHIStepLineNeg[1].y);
						}
						efis.efisContext.lineWidth = 0.7;
					}
					else{
						efis.efisContext.lineWidth = 1;
					}
					efis.efisContext.strokeStyle = 'white';
					efis.efisContext.stroke();
				}
				else {
					if(renderPos)
						drawShorterLine(efis.efisContext, AHIStepLine[0], AHIStepLine[1], halfLineLength, halfLineLength);

					if(i>0)
						if(renderNeg)
							drawShorterLine(efis.efisContext, AHIStepLineNeg[0], AHIStepLineNeg[1], halfLineLength, halfLineLength);
				}
				efis.efisContext.closePath();
				
				// Writing angles next to the lines
				if(fullLine) {
					var txtAngle = i;
					if(txtAngle > 90) 
						txtAngle = 90 - (txtAngle - 90);
					
					if(renderPos) {
						efis.efisContext.save();
						efis.efisContext.translate(AHIStepLine[0].x, AHIStepLine[0].y);
						efis.efisContext.rotate(efis.rollAngleRad);
						efis.efisContext.beginPath();
						efis.efisContext.fillStyle = 'white';
						efis.efisContext.font = (efis.fontSize * 0.7) + 'px ' + efis.DefaultFont;
						efis.efisContext.textAlign = "center";
						efis.efisContext.fillText(txtAngle, efis.sizeFactorEfis * 2 * -1, 3);
						efis.efisContext.fillText(txtAngle, (efis.sizeFactorEfis * 2) + (efis.efisWidth / (efis.horizonSizeFactor / 2)), 3);
						efis.efisContext.closePath();
						efis.efisContext.restore();
					}
					if(i>0) {
						if(renderNeg) {
							efis.efisContext.save();
							efis.efisContext.translate(AHIStepLineNeg[0].x, AHIStepLineNeg[0].y);
							efis.efisContext.rotate(efis.rollAngleRad);
							efis.efisContext.beginPath();
							efis.efisContext.fillStyle = 'white';
							efis.efisContext.font = (efis.fontSize * 0.7) + 'px ' + efis.DefaultFont;
							efis.efisContext.textAlign = "center";
							efis.efisContext.fillText(-txtAngle, efis.sizeFactorEfis * 2 * -1, 3);
							efis.efisContext.fillText(-txtAngle, (efis.sizeFactorEfis * 2) + (efis.efisWidth / (efis.horizonSizeFactor / 2)), 3);
							efis.efisContext.closePath();
							efis.efisContext.restore();
						}
					}
				}
			}
		}

		function drawEfisCrosshair() {
			var elementLineWidth = 3;
			var blockStart = 5;
			var blockEnd = 7;
			var elementFont = efis.fontSize + 'px ' + efis.DefaultFont;

			efis.efisContext.beginPath();
			efis.efisContext.lineWidth = elementLineWidth;
			efis.efisContext.fillStyle = 'yellow';
			efis.efisContext.strokeStyle = 'yellow';
			efis.efisContext.moveTo(efis.blockWidth * blockStart, (efis.efisHeight / 2));
			efis.efisContext.lineTo(efis.blockWidth * blockEnd, (efis.efisHeight / 2));
			efis.efisContext.moveTo(efis.blockWidth * blockEnd, (efis.efisHeight / 2) - (elementLineWidth / 2));
			efis.efisContext.lineTo(efis.blockWidth * blockEnd, (efis.efisHeight / 2) + (elementLineWidth * 3));
			efis.efisContext.moveTo(efis.blockWidth * (efis.qtyBlocks - blockStart), (efis.efisHeight / 2));
			efis.efisContext.lineTo(efis.blockWidth * (efis.qtyBlocks - blockEnd), (efis.efisHeight / 2));
			efis.efisContext.moveTo(efis.blockWidth * (efis.qtyBlocks - blockEnd), (efis.efisHeight / 2) - (elementLineWidth / 2));
			efis.efisContext.lineTo(efis.blockWidth * (efis.qtyBlocks - blockEnd), (efis.efisHeight / 2) + (elementLineWidth * 3));
			efis.efisContext.fillRect((efis.efisWidth / 2) - elementLineWidth, (efis.efisHeight / 2) - elementLineWidth, elementLineWidth * 2, elementLineWidth * 2);
			efis.efisContext.stroke();

			drawTextWithShadow(efis.efisContext, (data.pitchAngle * -1).toFixed(1) + 'ยบ', (efis.blockWidth * blockStart) - elementLineWidth, (efis.efisHeight / 2) + (efis.fontSize / 2.5), elementFont, 'right', 'white', 'black', elementLineWidth / 2);

			efis.efisContext.closePath();

		}

		function drawEfisVerticalSpeed() {
			var elementWidth = efis.blockWidth;
			var elementHeight = efis.efisHeight;
			var elementX = (efis.efisWidth - elementWidth);
			var elementY = 0;
			var elementCenterY = (elementY + elementHeight) / 2;
			var elementFontSize = efis.fontSize * 2;
			var elementSmallFontSize = elementFontSize / 3;
			var verticalSpeedDisplay = data.verticalSpeed.toFixed(1);
			var elementLineStartX = elementX + (elementWidth / 6);
			var elementLineEndX = (elementX + elementWidth) - (elementWidth / 2);
			
			// Draw translucid element space
			efis.efisContext.globalAlpha = 0.5;
			efis.efisContext.fillStyle = 'black';
			efis.efisContext.fillRect(elementX, elementY, elementWidth, elementHeight);
			efis.efisContext.globalAlpha = 1.0;

			// Draw center line
			if(0==1) {
				efis.efisContext.beginPath();
				efis.efisContext.strokeStyle = 'white';
				efis.efisContext.lineWidth = 1;
				efis.efisContext.moveTo(elementX, elementCenterY);
				efis.efisContext.lineTo(elementX + elementWidth, elementCenterY);
				efis.efisContext.stroke();
				efis.efisContext.closePath();
			}

			// Draw numbers and lines
			var maxVerticalSpeed = efis.VerticalSpeedFOV; // m/s

			if(0==1) {
				if(Math.abs(data.verticalSpeed / efis.VerticalSpeedUnitFactor) > maxVerticalSpeed)
					maxVerticalSpeed = Math.ceil(abs(data.verticalSpeed / efis.VerticalSpeedUnitFactor));
			}

			var VerticalSpeedDivisions = efis.VerticalSpeedSteps;
			var textX = (elementX + elementWidth) - (elementWidth / 6);
			var VSPixels = elementHeight / ((maxVerticalSpeed + 1) * 2);
			
			for(i=0; i<=maxVerticalSpeed; i++) {
				if(i % VerticalSpeedDivisions != 0)
					continue;

				efis.efisContext.beginPath();

				var textY = elementCenterY - (i * VSPixels);

				efis.efisContext.moveTo(elementLineStartX, textY);
				efis.efisContext.lineTo(elementLineEndX, textY);


				textY = textY + (elementSmallFontSize / 3);
				efis.efisContext.fillStyle = 'white';
				efis.efisContext.strokeStyle = 'white';
				efis.efisContext.lineWidth = 1;
				efis.efisContext.font = elementSmallFontSize + 'px ' + efis.DefaultFont;
				efis.efisContext.textAlign = "right";
				efis.efisContext.fillText(i, textX, textY);
				if(i>0) {
					textY = elementCenterY + (i * VSPixels);

					efis.efisContext.moveTo(elementLineStartX, textY);
					efis.efisContext.lineTo(elementLineEndX, textY);

					textY = textY + (elementSmallFontSize / 3);
					efis.efisContext.fillText(-i, textX, textY);
				}

				if(i==maxVerticalSpeed) { // last number
					efis.efisContext.moveTo(elementLineStartX, elementCenterY);
					textY = elementCenterY - (i * VSPixels);
					efis.efisContext.lineTo(elementLineStartX, textY);
					textY = elementCenterY + (i * VSPixels);
					efis.efisContext.lineTo(elementLineStartX, textY);
				}

				efis.efisContext.stroke();
				efis.efisContext.closePath();
			}

			// Draw the line for the Vertical Speed value
			efis.efisContext.beginPath();
			efis.efisContext.strokeStyle = 'yellow';
			efis.efisContext.lineWidth = 2;
			var pointerFactor = 0.8;
			
			var vsLineY = elementCenterY - ((data.verticalSpeed / efis.VerticalSpeedUnitFactor) * VSPixels);
			var vsLineY2 = elementCenterY - ((data.verticalSpeed / efis.VerticalSpeedUnitFactor) * VSPixels * pointerFactor);

			if((data.verticalSpeed / efis.VerticalSpeedUnitFactor) > maxVerticalSpeed) {
				vsLineY = elementCenterY - (maxVerticalSpeed * VSPixels);
				vsLineY2 = elementCenterY - (maxVerticalSpeed * VSPixels * pointerFactor);
				efis.efisContext.strokeStyle = 'orange';
			}else if((data.verticalSpeed / efis.VerticalSpeedUnitFactor) < -maxVerticalSpeed) {
				vsLineY = elementCenterY + (maxVerticalSpeed * VSPixels);
				vsLineY2 = elementCenterY + (maxVerticalSpeed * VSPixels * pointerFactor);
				efis.efisContext.strokeStyle = 'orange';
			}

			efis.efisContext.moveTo((elementX + elementWidth), vsLineY2);
			efis.efisContext.lineTo(elementLineStartX, vsLineY);

			efis.efisContext.stroke();
			efis.efisContext.closePath();


			
		}

		function drawEfisGroundSpeed() {
			var elementWidth = (efis.efisWidth / 6);
			var elementHeight = (efis.efisHeight);
			var elementX = 0;
			var elementY = 0;
			var elementFontSize = efis.fontSize * 2;
			var elementSmallFontSize = elementFontSize / 2;
			var groundSpeedDisplay = data.groundSpeed * efis.SpeedUnitFactor;

			// Draw translucid element space
			efis.efisContext.globalAlpha = 0.2;
			efis.efisContext.fillStyle = 'black';
			efis.efisContext.fillRect(elementX, elementY, elementWidth, elementHeight);
			efis.efisContext.globalAlpha = 1.0;


			// Draw Speed Scroller
			efis.efisContext.lineWidth = 1;
			var startSpeed = parseInt(groundSpeedDisplay - ((efis.SpeedFOV / 2) + efis.SpeedSteps));
			if(startSpeed < 0) startSpeed = 0;
			var endSpeed = parseInt(groundSpeedDisplay + ((efis.SpeedFOV / 2) + efis.SpeedSteps));

			var numberX = elementX + elementWidth;
			var lineX1 = numberX;
			var lineX2 = numberX - ((elementWidth / 8) * 0.9);
			var textX = numberX - (elementWidth / 8);

			for(i=startSpeed; i<=endSpeed;i++) {
				if(i % efis.SpeedSteps == 0) {
					var startingPosY = (elementHeight / 2) - (groundSpeedDisplay * (elementHeight / efis.SpeedFOV));
					var numberY = startingPosY + (i * (elementHeight / efis.SpeedFOV) );
					numberY = elementHeight - numberY;

					efis.efisContext.beginPath();
					efis.efisContext.fillStyle = 'white';
					efis.efisContext.font = elementSmallFontSize + 'px ' + efis.DefaultFont;
					efis.efisContext.textAlign = "right";
					efis.efisContext.fillText(i, textX, numberY + (elementSmallFontSize / 2.5));
					efis.efisContext.moveTo(lineX1, numberY);
					efis.efisContext.lineTo(lineX2, numberY);
					if(i>0) {
						efis.efisContext.moveTo(lineX1, numberY + ((elementHeight / efis.SpeedFOV) * (efis.SpeedSteps /2)));
						efis.efisContext.lineTo(lineX2, numberY + ((elementHeight / efis.SpeedFOV) * (efis.SpeedSteps /2)));
					}
					efis.efisContext.strokeStyle = 'white';
					efis.efisContext.stroke();
					efis.efisContext.closePath();
				}
			}
			
			// Draw box on center of the element
			efis.efisContext.beginPath();
			drawBoxWithTextAbsPosition(efis.efisContext, groundSpeedDisplay.toFixed(0), 'white', elementFontSize, 'right', P(elementX, (elementHeight / 2) - (elementFontSize / 2)), P(elementWidth, elementFontSize), '000');

			// Draw unit
			efis.efisContext.fillStyle = 'white';
			efis.efisContext.font = elementSmallFontSize + 'px ' + efis.DefaultFont;
			efis.efisContext.textAlign = "left";
			efis.efisContext.fillText(efis.SpeedUnitLabel, elementX, (elementHeight / 2) + elementFontSize);
			efis.efisContext.closePath();

		}

		function drawEfisAltitude() {
			var elementWidth = (efis.efisWidth / 6);
			var elementHeight = (efis.efisHeight);
			var elementX = (efis.efisWidth - elementWidth - efis.blockWidth);
			var elementY = 0;
			var elementFontSize = efis.fontSize * 2;
			var elementSmallFontSize = elementFontSize / 2;
			var altitudeDisplay = parseInt(data.altitude / efis.AltitudeUnitFactor);

			// Draw translucid element space
			efis.efisContext.globalAlpha = 0.2;
			efis.efisContext.fillStyle = 'black';
			efis.efisContext.fillRect(elementX, elementY, elementWidth, elementHeight);
			efis.efisContext.globalAlpha = 1.0;

			// Draw Altitude Scroller
			var startAltitude = parseInt(altitudeDisplay - ((efis.AltitudeFOV / 2) + efis.AltitudeSteps));
			var endAltitude = parseInt(altitudeDisplay + ((efis.AltitudeFOV / 2) + efis.AltitudeSteps));

			var numberX = elementX;
			var lineX1 = numberX;
			var lineX2 = numberX + ((elementWidth / 8) * 0.9);
			var textX = numberX + (elementWidth / 8);

			for(i=startAltitude; i<=endAltitude;i++) {
				if(i % efis.AltitudeSteps == 0) {
					var startingPosY = (elementHeight / 2) - (altitudeDisplay * (elementHeight / efis.AltitudeFOV));
					var numberY = startingPosY + (i * (elementHeight / efis.AltitudeFOV) );
					numberY = elementHeight - numberY;

					efis.efisContext.beginPath();
					efis.efisContext.fillStyle = 'white';
					efis.efisContext.font = elementSmallFontSize + 'px ' + efis.DefaultFont;
					efis.efisContext.textAlign = "left";
					efis.efisContext.fillText(i, textX, numberY + (elementSmallFontSize / 2.5));
					efis.efisContext.moveTo(lineX1, numberY);
					efis.efisContext.lineTo(lineX2, numberY);
					efis.efisContext.moveTo(lineX1, numberY + ((elementHeight / efis.AltitudeFOV) * (efis.AltitudeSteps /2)));
					efis.efisContext.lineTo(lineX2, numberY + ((elementHeight / efis.AltitudeFOV) * (efis.AltitudeSteps /2)));
					efis.efisContext.strokeStyle = 'white';
					efis.efisContext.stroke();
					efis.efisContext.closePath();
				}
			}
			
			// Draw box on center of the element
			efis.efisContext.beginPath();
			drawBoxWithTextAbsPosition(efis.efisContext, altitudeDisplay, 'white', elementFontSize, 'right', P(elementX, (elementHeight / 2) - (elementFontSize / 2)), P(elementWidth, elementFontSize), '000', efis.AltitudeSmallTextNumber);

			// Draw unit
			efis.efisContext.fillStyle = 'white';
			efis.efisContext.font = elementSmallFontSize + 'px ' + efis.DefaultFont;
			efis.efisContext.textAlign = "right";
			efis.efisContext.fillText(efis.AltitudeUnitLabel, elementX + elementWidth, (elementHeight / 2) + elementFontSize);
			efis.efisContext.closePath();




		}

		function AngleToRadians(angle) {
			return angle * Math.PI / 180;
		}

		function drawEfisBankAngle() {
			var elementWidth = (efis.efisWidth / 3);
			var elementHeight = (efis.efisHeight / 6);
			var elementX = (efis.efisWidth / 2) - (elementWidth / 2);
			var elementY = efis.blockHeight;
			var elementCenterX = elementX + (elementWidth / 2);

			var lineLength = (efis.efisHeight / 2) - elementY;

			// Draw lines
			efis.efisContext.strokeStyle = 'white';

			for(i=0; i<=30; i+=10) {
				var x1 = (efis.efisWidth / 2);
				var y1 = (efis.efisHeight / 2);
				var x2 = x1 + lineLength * Math.sin(AngleToRadians(i));
				var y2 = y1 - lineLength * Math.cos(AngleToRadians(i));

				if(i==0 || i==30)
					efis.efisContext.lineWidth = 2;
				else
					efis.efisContext.lineWidth = 1;

				drawShorterLine(efis.efisContext, P(x1, y1), P(x2, y2), (efis.efisHeight / 2) - (efis.blockHeight * 2), 0);
				if(i>0) {
					x2 = (x1 - (lineLength * Math.sin(AngleToRadians(i))));
					drawShorterLine(efis.efisContext, P(x1, y1), P(x2, y2), (efis.efisHeight / 2) - (efis.blockHeight * 2), 0);
				}
			}

			// Draw bank arrow
			var bankAngle = data.rollAngle;
			if(bankAngle > -50 && bankAngle < 50) {
				var arrowAngle = 10;

				x1 = elementCenterX + (lineLength - efis.blockHeight) * Math.sin(AngleToRadians(bankAngle));
				y1 = (efis.efisHeight / 2) - (lineLength - efis.blockHeight) * Math.cos(AngleToRadians(bankAngle));

				var x2a = x1 - (efis.blockWidth * Math.sin(AngleToRadians(-arrowAngle + bankAngle)));
				var y2a = y1 + (efis.blockHeight * Math.cos(AngleToRadians(-arrowAngle + bankAngle)));
				var x2b = x1 - (efis.blockWidth * Math.sin(AngleToRadians(arrowAngle + bankAngle)));;
				var y2b = y1 + (efis.blockHeight * Math.cos(AngleToRadians(arrowAngle + bankAngle)));

				efis.efisContext.beginPath();
				efis.efisContext.strokeStyle = 'yellow';
				efis.efisContext.lineWidth = 2;
				efis.efisContext.moveTo(x1, y1);
				efis.efisContext.lineTo(x2a, y2a);
				efis.efisContext.moveTo(x1, y1);
				efis.efisContext.lineTo(x2b, y2b);
				efis.efisContext.moveTo(x2a, y2a);
				efis.efisContext.lineTo(x2b, y2b);

				efis.efisContext.stroke();
				efis.efisContext.closePath();
			}
		}

		function drawEfisBatterySection() {
			var elementWidth = efis.blockWidth * 2;
			var elementHeight = efis.blockHeight * 2;
			var elementX = efis.blockWidth * 3.5;
			var elementY = (efis.efisHeight) - elementHeight - (efis.blockHeight * 1.5);
			var padding = 1.5;
			var elementFont = efis.fontSize + 'px ' + efis.DefaultFont;
			var elementSmallFont = efis.fontSize * 0.8 + 'px ' + efis.DefaultFont;

			// Draw fuel % bar
			var barColor = 'limegreen';
			if(data.fuelPercent < 35)
				barColor = 'yellow';
			if(data.fuelPercent < 15)
				barColor = 'red';
			
			var displayText = data.battCellVoltage.toFixed(2) + 'v'
			var barH = efis.blockHeight / 1.5;
			var barX = elementX + efis.blockWidth * 1.5;
			var barY = elementY;

			drawTextWithShadow(efis.efisContext, 'Batt', elementX, barY + (barH / 1.3), elementSmallFont, 'left', 'white', 'black', padding);
			drawProgressBar(efis.efisContext, displayText, barX, barY, elementWidth, barH, data.fuelPercent, barColor, elementSmallFont, padding);

			// Draw RSSI % bar
			barColor = 'limegreen';
			if(data.rssiPercent < 50)
				barColor = 'yellow';
			if(data.rssiPercent < 20)
				barColor = 'red';
				
			barX = elementX + efis.blockWidth * 1.5;
			barY = elementY + (efis.blockHeight * 1);

			displayText = data.rssiPercent.toFixed(0) + '%'
			drawTextWithShadow(efis.efisContext, 'RSSI', elementX, barY + (barH / 1.3), elementSmallFont, 'left', 'white', 'black', padding);
			drawProgressBar(efis.efisContext, displayText, barX, barY, elementWidth, barH, data.rssiPercent, barColor, elementSmallFont, padding);

			// Draw battery icon and Voltage


		}

		function renderEFIS(data) {
			var startTime = performance.now();

			UpdateViewPortSize();

			// Declare basic objects and resize canvas to the hud available size
			efis.efisContext = efis.efisCanvas.getContext("2d"),
			efis.efisWidth = efis.hudView.offsetWidth;
			efis.efisHeight = efis.hudView.offsetHeight;
			efis.efisCanvas.width = efis.efisWidth;
			efis.efisCanvas.height = efis.efisHeight;
			efis.efisContext.clearRect(0, 0, efis.efisWidth, efis.efisHeight);
			
			// Line length gets the diagonal size of the EFIS.
			efis.lineLength = Math.pow((efis.efisWidth * efis.efisWidth) + (efis.efisHeight * efis.efisHeight), 0.5);
			efis.pitchDegPixels = efis.efisHeight / efis.verticalFOV;
			efis.sizeFactorEfis = efis.efisWidth / efis.horizontalFOV;
			efis.blockWidth = efis.efisWidth / efis.qtyBlocks;
			efis.blockHeight = efis.efisHeight / efis.qtyBlocks;
			efis.fontSize = parseInt((efis.blockHeight / 4) * efis.fontSizeFactor);

			// Draw Sky, Ground and Horizon
			drawEfisHorizonGroundSky();
			
			// Draw Artificial horizon step lines
			drawEfisArtifitialHorizonStepLines();
			
			// Draw Crosshair
			drawEfisCrosshair();
			
			// Draw Heading indicator
			drawEfisHeadingIndicator();
			
			// Draw Ground Speed
			drawEfisGroundSpeed();
			
			// Draw Altitude
			drawEfisAltitude();

			// Draw Vertical Speed
			drawEfisVerticalSpeed();

			// Draw Bank angle
			drawEfisBankAngle();

			// Draw Battery information
			drawEfisBatterySection();

			// Debug Info
			var endTime = performance.now();
			var elapsedTime = (endTime - startTime).toFixed(1);

			if(1==1) {
				var debugFont = (efis.fontSize / 1.5) + 'px ' + efis.DefaultFont
				var debugText = efis.efisWidth + 'x' + efis.efisHeight + 'px, ' + elapsedTime + 'ms';
				
				drawTextWithShadow(efis.efisContext, debugText, efis.blockWidth * 3, efis.blockHeight * 0.5, debugFont, 'left', 'white', 'black', 1);

			}
		}

		var rollDirection = 0.5;
		var pitchDirection = 0.5;
		var yawDirection = 0.5;
		var groundSpeedDirection = 20;
		var verticalSpeedDirection = 50;
		var altitudeDirection = 200;
		var voltageDirection = -0.01;
		var ampDrawDirection = 0.3;
		var rssiDirection = -1;

		function simulateFlight() {
			// Make it roll
			if(Math.round(Math.random() * 100) == 1) // Odds of changing direction
				rollDirection = -rollDirection;

			if(Math.round(Math.random() * 1) == 1) // Odds of moving on that direction
				data.rollAngle += rollDirection;

			// Detect range ends				
			if(data.rollAngle > 180)
				data.rollAngle = -179;
			else if(data.rollAngle < -180)
				data.rollAngle = 179;
			
			// Make it pitch
			if(Math.round(Math.random() * 200) == 1) // Odds of changing direction
				pitchDirection = -pitchDirection;
			
			if(Math.round(Math.random() * 1) == 1) // Odds of moving on that direction
				data.pitchAngle += pitchDirection;

			// Detect range ends				
			if(data.pitchAngle > 90) {
				pitchDirection = -pitchDirection;
				data.pitchAngle = 89;
				if(data.rollAngle > 0) 
					data.rollAngle -= 180;
				else
					data.rollAngle += 180;
			}
			else if(data.pitchAngle < -90) {
				pitchDirection = -pitchDirection;
				data.pitchAngle = -89;
				if(data.rollAngle > 0) 
					data.rollAngle -= 180;
				else
					data.rollAngle += 180;
			}
			
			// Make it Yaw
			if(Math.round(Math.random() * 1000) == 1) // Odds of changing direction
				yawDirection = -yawDirection;

			if(Math.round(Math.random() * 1) == 1) // Odds of moving on that direction
				data.heading += yawDirection;

			// Detect range ends				
			if(data.heading > 180)
				data.heading = -179;
			else if(data.heading < -180)
				data.heading = 179;
			
			// Make it change speed
			if(Math.round(Math.random() * 100) == 1) // Odds of changing direction
				groundSpeedDirection = -groundSpeedDirection;

			if(Math.round(Math.random() * 3) == 1) // Odds of moving on that direction
				data.groundSpeed += groundSpeedDirection;

			// Detect range ends				
			if(data.groundSpeed > 3333) {
				groundSpeedDirection = -groundSpeedDirection;
				data.groundSpeed = 3332;
			}
			else if(data.groundSpeed < 400) {
				groundSpeedDirection = -groundSpeedDirection;
				data.groundSpeed = 401;
			}
			
			// Make it change altitude
			if(Math.round(Math.random() * 10000) == 1) // Odds of changing direction
				altitudeDirection = -altitudeDirection;

			if(Math.round(Math.random() * 1) == 1) // Odds of moving on that direction
				data.altitude += altitudeDirection;

			// Detect range ends				
			if(data.altitude > 500000) {
				altitudeDirection = -altitudeDirection;
				data.altitude = 49999;
			}
			else if(data.altitude < -100000) {
				altitudeDirection = -altitudeDirection;
				data.altitude = -9999;
			}

			// Make it change vertical speed
			if(Math.round(Math.random() * 100) == 1) // Odds of changing direction
				verticalSpeedDirection = -verticalSpeedDirection;

			if(Math.round(Math.random() * 3) == 1) // Odds of moving on that direction
				data.verticalSpeed += verticalSpeedDirection;

			// Detect range ends				
			if(data.verticalSpeed > 1800) {
				verticalSpeedDirection = -verticalSpeedDirection;
				data.verticalSpeed = 1750;
			}
			else if(data.verticalSpeed < -1800) {
				verticalSpeedDirection = -verticalSpeedDirection;
				data.verticalSpeed = -1750;
			}

			// Make it draw battery
			if(Math.round(Math.random() * 100) == 1) { // Odds of moving on that direction
				data.battCellVoltage += voltageDirection;
				data.fuelPercent = ((data.battCellVoltage - 3.3) * 100) / (4.2 - 3.3);
			}

			// Detect range ends				
			if(data.battCellVoltage < 3.3) {
				data.battCellVoltage = 4.20;
				data.fuelPercent = 100;
			}
		}

		function openGoogleMaps(lat, lon){
			// If it's an iPhone..
			if( (navigator.platform.indexOf("iPhone") != -1) 
				|| (navigator.platform.indexOf("iPod") != -1)
				|| (navigator.platform.indexOf("iPad") != -1))
				//window.open("maps://www.google.com/maps/dir/?api=1&travelmode=driving&layer=traffic&destination=" + lat + "," + lon + "");
				window.open("http://maps.apple.com/?q=" + lat + "," + lon + "");
			else
				window.open("https://www.google.com/maps/dir/?api=1&travelmode=driving&layer=traffic&destination=" + lat + "," + lon + "");
		}
		
		function centerMap(data) {
			// Center the map
			var oldCenter = map.getView().getCenter();
			map.getView().setCenter(
				ol.proj.fromLonLat([data.gpsLongitude, data.gpsLatitude])
				);
			var newCenter = map.getView().getCenter();
			map.getView().setCenter(oldCenter);
			map.getView().animate({center: newCenter});
		}

		function secondsToNiceTime(seconds) 
		{
			if(seconds > 60 * 60 * 24) // More than one day means never
				return "Never";
			
			var minutes = 0;
			var hours = 0;

			if(seconds > (60 * 60)) 
			{
				hours = Math.floor(seconds / (60 * 60));
				seconds = seconds - (hours * 60 * 60);
			}

			if(seconds > 60) 
			{
				minutes = Math.floor(seconds / 60);
				seconds = seconds - (minutes * 60);
			}

			var ret = "";
			if(hours>0)
				ret += hours + "h ";

			if(minutes>0)
				ret += minutes + "m ";
			
			ret += seconds + "s";
			return ret;
		}

		function centimetersToNiceDistance(centimeters)
		{
			var meters = parseInt(centimeters / 100);
			if(meters > 999)
				return (meters / 1000).toFixed(1) + " km";
			else
				return meters + "m";
		}

		function getConnectionIcon()
		{
			var dtNow = new Date();
			var timeSinceLastMessage = parseInt((dtNow - lastMessageDate) / 1000);
			var ret = "";

			if(!mqttConnected)
				ret = "broken";
			if(timeSinceLastMessage <= 10)
				ret = "ok";
			else if (timeSinceLastMessage <= 30)
				ret = "attention";
			else
				ret = "error";

			return "img/connection_" + ret + ".png";
		}

		function getCellSignalIcon(bars)
		{
			var ret = "broken";
			if(bars==1)
				ret = "poor";
			if(bars==2)
				ret = "good";
			if(bars==3)
				ret = "excelent";

			return "img/cell_" + ret + ".png";
		}

		function getRadioIcon(signalPercent)
		{
			var ret = "broken";
			if(signalPercent >= 10 && signalPercent < 30)
				ret = "bad";
			else if(signalPercent >= 30 && signalPercent < 50)
				ret = "poor";
			else if(signalPercent >= 40)
				ret = "ok";

			return "img/rx_" + ret + ".png";
		}

		function getBatteryIcon(batteryPercent)
		{
			var ret = "0";
			if(batteryPercent >= 5 && batteryPercent <= 20)
				ret = "20";
			else if(batteryPercent > 20 && batteryPercent <= 40)
				ret = "40";
			else if(batteryPercent > 40 && batteryPercent <= 60)
				ret = "60";
			else if(batteryPercent > 60 && batteryPercent <= 80)
				ret = "80";
			else if(batteryPercent > 80)
				ret = "100";

			return "img/battery_" + ret + ".png";
		}

		function getGPSIcon(sats, hdop)
		{
			var ret = "broken";
			if(hdop != 0 && hdop < 5) 
			{
				if(sats <= 7)
					ret = "bad";
				else if(sats >=8 && sats <= 10)
					ret = "poor";
				else if(sats >= 11)
					ret = "ok";
			}
			return "img/gps_" + ret + ".png";
		}

		function getHardwareHealthyIcon(isHwHealthy)
		{
			var ret = "error";
			if(isHwHealthy == 1)
				ret = "ok";

			return "img/health_" + ret + ".png";
		}

		function updateDataView(data)
		{
			var PlusCodeCoordinates = OpenLocationCode.encode(data.gpsLatitude, data.gpsLongitude);
			var armedText = " (DISARMED)";
			if(data.uavIsArmed == 1)
				armedText = " (ARMED)";

			var gps3DText = "";
			if(data.gps3DFix == 1)
				gps3DText = " [3D]";

			var wpMissionColor = "#FFF";
			var wpMissionText = "Not loaded";
			if(data.waypointCount > 0)
			{
				wpMissionText = data.currentWaypointNumber + ' / ' + data.waypointCount;
				if(data.isWaypointMissionValid == 1)
					wpMissionColor = "#3F3"
				else
					wpMissionColor = "#F33"
			}


			document.getElementById("waipointPlaceHolder").style.color = wpMissionColor;
			document.getElementById("waipointPlaceHolder").innerHTML = wpMissionText;

			document.getElementById("cellIcon").src = getCellSignalIcon(data.cellSignalStrength);
			document.getElementById("radioIcon").src = getRadioIcon(data.rssiPercent);
			document.getElementById("batteryIcon").src = getBatteryIcon(data.fuelPercent);
			document.getElementById("connectionIcon").src = getConnectionIcon();
			document.getElementById("gpsIcon").src = getGPSIcon(data.gpsSatCount, data.gpsHDOP);
			document.getElementById("hardwareHealthIcon").src = getHardwareHealthyIcon(data.isHardwareHealthy);
			document.getElementById("activeModePlaceHolder").innerHTML = data.flightMode + armedText;
			document.getElementById("coordinatesPlaceHolder").innerHTML = '<a style="cursor: pointer; color: #00BFFF;" onclick="openGoogleMaps(' + data.gpsLatitude + ',' + data.gpsLongitude + ');" ontouchstart="openGoogleMaps(' + data.gpsLatitude + ',' + data.gpsLongitude + ');">' + PlusCodeCoordinates + '</a>';
			document.getElementById("homeDistancePlaceHolder").innerHTML = centimetersToNiceDistance(data.homeDistance);
			document.getElementById("gpsInfoPlaceHolder").innerHTML = data.gpsSatCount + ' Sats (' + data.gpsHDOP + ' HDOP)' + gps3DText;
			document.getElementById("aziElevPlaceHolder").innerHTML = data.azimuth + 'ยบ / ' + data.elevation + 'ยบ';
			document.getElementById("callsignPlaceHolder").innerHTML = data.callsign;

			//var onFlightTimeText = data.powerTime + " / " + data.flightTime;
			//document.getElementById("onFlightTimePlaceHolder").innerHTML = onFlightTimeText;

		}

		var aircraftIconFeatures=[];

		var aircraftIconStyle = new ol.style.Style({
			image: new ol.style.Icon({
				anchor: [0.5, 0.5],
				anchorXUnits: 'fraction',
				anchorYUnits: 'fraction',
				opacity: 1.0,
				src: 'img/aircraft.png', 
				scale: (0.05 * window.devicePixelRatio),
				rotateWithView: true
				})
		});
		
		var aircraftVectorSource = new ol.source.Vector({
			features: aircraftIconFeatures //add an array of features
		});

		var aircraftVectorLayer = new ol.layer.Vector({
			source: aircraftVectorSource,
			style: aircraftIconStyle
		});

		map.addLayer(aircraftVectorLayer);

		function drawAircraftOnMap(data)
		{
			// Removing Previous Aircraft from the VectorSource
			aircraftVectorSource.clear();

			// Adding the updated aircraft position to the VectorSource
			var iconGeometry = new ol.geom.Point(
				ol.proj.transform([data.gpsLongitude, data.gpsLatitude], 'EPSG:4326','EPSG:3857')
			);
			
			var aircraftIconFeature = new ol.Feature({
				geometry: iconGeometry
			});

			// Clear previous aircraft and add new
			aircraftIconFeatures = [];
			aircraftIconFeatures.push(aircraftIconFeature);			
			aircraftVectorSource.addFeatures(aircraftIconFeatures);
			
			// Set reading
			aircraftIconStyle.getImage().setRotation(AngleToRadians(data.heading));
		}
		
		document.addEventListener("touchmove", function(e){
			e.preventDefault();
		},{passive: false});
		
		window.onresize = function(event) {
			renderEFIS(data);
		};

		window.onload = function(event) {
			renderEFIS(data);
			MQTTconnect();

			var timerEFIS = setInterval(function(){ 
				//simulateFlight();
				renderEFIS(data);
			}, 100); // 33 = 30fps, 66 = 15fps, 100 = 10fps, 200 = 5fps, 500 = 2fps

			var timerMapAndData = setInterval(function(){ 
				drawAircraftOnMap(data);
				updateDataView(data);
			}, 500); // 33 = 30fps, 66 = 15fps, 100 = 10fps, 200 = 5fps, 500 = 2fps

			var timerCenterMap = setInterval(function(){ 
				// Set it false so the next time this routine will move the map
				if(user_moved_map == true)
					user_moved_map = false;
				else
					centerMap(data);
			}, 5000);

		}

	</script>
  </body>
</html>